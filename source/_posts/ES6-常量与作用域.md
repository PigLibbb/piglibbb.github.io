---
title: ES6-常量与作用域
date: 2020-11-10 20:46:09
categories: 
- 前端基础
- JavaScript
tags:
- ES6
- 作用域
- 变量提升
- 变量对象
- 临时死区
---

从这一篇博客开始，整体把前端能够用到的知识点统一梳理一下，也算是把自己已知已会的信息进行一个汇总。

初期的前端基础知识点会相对轻松一些，主要还是通过答题、摘要、要文背诵的形式，把基础的知识点“枚举出来”。这个过程中会减少一些对比论证的过程，不是以“讲解”为目的，而是为了复习

后续的业务模型、场景总结、团队管理知识点，则会有更多的发散讨论的信息（很期待我的总结，也很期望我能坚持下去）

## 变量声明
### var、let、const 的差异

常规用来举例论证 var 与 let 的一个 case
```javascript
var a = [];
for (var i = 0; i < 10; i++) { // var 与 let
  a[i] = function () {
    console.log(i);
  };
}
a[6]() // var: 10; let: 6;
```
涉及原理：块级作用域，稍后介绍。

**一句话记忆**：
> const 声明常量，不可改变，引用变量可改变属性；let 声明参数可修改；前两者声明会产生暂时性死区，导致变量不可在声明前使用，会报错，所以不支持变量提升；同时这两个变量满足块级作用域，仅在块级作用域内可访问；var 则具备变量提升，无 var 自动声明全局变量的特性。

### 变量提升与暂时性死区

**变量提升**：同一作用域下，变量可以在声明前使用，值为 undefined
**暂时性死区**：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，**只有等到声明变量的那一行代码出现，才可以获取和使用该变量**
禁止重复声明：let、const 不允许在相同作用域内，重复声明同一个变量
暂时性死区意义：为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

### 块级作用域与作用域

**作用域**：块级作用域、函数作用域、全局作用域
**块级作用域**：包含在两个大括号之间的内容，常见条件判定、循环。作用域内的变量无法被作用域外访问。
**作用域链**：由深到浅，由内而外的查询变量。使用一个变量从当前作用域查询数据，逐渐向上层查找，最终查找到 window 对象

### 活动对象与变量对象

**执行上下文**：制定 JS 运行时所处环境的变量、参数等信息，本质就是维护了当前的数据全集
**全局上下文**：就是指 window 对象
**函数上下文**：常指函数的 arguments 对象
**执行上下文生命周期**：创建（变量对象VO、作用域链scope、this指向），执行（活动对象AO、执行代码），回收（执行上下文出栈）
**变量对象&活动对象**：Variable Object 变量对象主要是对于初始化声明过程中的变量参数进行描述；随着 JS 的实际运行，变量对象会变成活动 Active Object 对象，同时所用的参数也会更新到实际的运行变量。
